---
title: 算法学习笔记
date: 2022-04-25 20:13:36
urlname: algorithm-notes
tags:
- LeetCode
- 算法
categories:
toc: true
---

我的第一篇博客，记录一下自己学习算法的过程。

<!-- more -->

## 关于
作为一个工作快5年的老程序员，希望现在重新开始学习算法不算太晚。其实大学里也学过算法，然而那时候课堂上老师只是照本宣科，课外自己也没有认真看书和写代码，所以考完试之后就忘得差不多了。到后来毕业找工作的时候虽然还有一点印象，但是对于算法的具体实现细节就完全不记得了。而且那时候的我十分看不起刷题这种行为，现在想想觉得很幼稚。

工作之后，虽然几乎没怎么用到算法，但是偶尔在需要用到算法的时候发现自己的算法储备捉襟见肘，甚至想要百度的时候也想不到合适的关键词。另外，在看各种库和框架的代码的时候，也时常看到一些算法的影子。最重要的是，在做了几年的CRUD Boy之后慢慢意识到，要做那些比较底层和基础的开发工作，对算法和代码能力的要求都是比较高的。因此也断断续续刷过一阵子算法题。最近看了google大佬[《我的算法学习之路》](https://blog.lucida.me/blog/on-learning-algorithms/)这篇文章之后，更加意识到学习算法的重要性。于是决定重新系统地学习一遍算法，并且用这篇博客来记录学习的过程。

## 计划
通过看书和刷题结合的方式学习算法。
- 书：《算法设计指南》为主，配合《算法设计与分析》和《算法4》
- 刷题：
    - 按照[《剑指Offer》](https://leetcode-cn.com/study-plan/lcof/?progress=upawfgd)的顺序做题，同时看《算法设计指南》书上相对应的知识点
    - 按专题做LeetCode上的高频题（参考[代码随想录](https://programmercarl.com/)）

> 刷题不是为了面试能遇到原题，而是巩固相关的数据结构和算法，掌握某一类问题的解决方法。

## LeetCode做题记录

### [剑指 Offer 09. 用两个栈实现队列](https://leetcode-cn.com/problems/yong-liang-ge-zhan-shi-xian-dui-lie-lcof/)
**思路：**一个栈用于输入队列，一个栈用于输出队列，当输出栈为空的时候把输入栈的内容Push到输出栈中
```Go
type CStack struct {
	arr []int
}

func (s *CStack) Push(value int) {
	s.arr = append(s.arr, value)
}

func (s *CStack) Pop() int {
	top := s.arr[len(s.arr)-1]
	s.arr = s.arr[:len(s.arr)-1]
	return top
}

func (s *CStack) Len() int {
	return len(s.arr)
}

type CQueue struct {
	in  CStack
	out CStack
}

func Constructor() CQueue {
	return CQueue{}
}

func (q *CQueue) AppendTail(value int) {
	q.in.Push(value)
}

func (q *CQueue) DeleteHead() int {
    if q.out.Len() == 0 {
        if q.in.Len() == 0 {
            return -1
        }
        for q.in.Len() > 0 {
            q.out.Push(q.in.Pop())
        }
    }
    return q.out.Pop()
}
```

### [剑指 Offer 30. 包含min函数的栈](https://leetcode-cn.com/problems/bao-han-minhan-shu-de-zhan-lcof/)
**思路：**一开始看题目看到min操作时，第一反应是要排序，即然要排序那就不可能用O(1)复杂度完成push和pop。不过既然题目要求用O(1)完成，说明可以有排序以外的方法。
想了很久，在纸上**模拟**了几遍，最终发现了华点：由于整体是一个栈，那就限制了插入和删除的顺序，于是有些值是不可能成为min的返回结果的，因此没必要对所有值进行排序，只需要按插入的顺序维护当前的最小值。
**算法：**用一个数据栈、一个最小值栈，push时把数据push到数据栈，如果数据小于或等于最小值栈的top值，就把当前数据push到最小值栈。min函数返回最小值栈的top值。
```Go
type MinStack struct {
    dataStack []int
    minStack []int
}


/** initialize your data structure here. */
func Constructor() MinStack {
    return MinStack{}
}


func (this *MinStack) Push(x int)  {
    this.dataStack = append(this.dataStack, x)

    if len(this.minStack) == 0 || x <= this.minStack[len(this.minStack)-1] {
        this.minStack = append(this.minStack, x)
    }
}


func (this *MinStack) Pop()  {
    if len(this.dataStack) == 0 {
        return
    }

    top := this.dataStack[len(this.dataStack)-1]
    this.dataStack = this.dataStack[:len(this.dataStack)-1]

    if top == this.minStack[len(this.minStack)-1] {
        this.minStack = this.minStack[:len(this.minStack)-1]
    }
}


func (this *MinStack) Top() int {
    if len(this.dataStack) == 0 {
        return 0
    }

    return this.dataStack[len(this.dataStack)-1]
}


func (this *MinStack) Min() int {
    if len(this.minStack) == 0 {
        return 0
    }

    return this.minStack[len(this.minStack)-1]
}
```

### [剑指 Offer 06. 从尾到头打印链表](https://leetcode-cn.com/problems/cong-wei-dao-tou-da-yin-lian-biao-lcof/)
**思路：**从尾到头打印对于链表来说是一个FILO的操作，因此自然地想到栈或者递归（本质也是栈）。
```Go
func reversePrint(head *ListNode) []int {
    var stack []int

    for head != nil {
        stack = append(stack, head.Val)
        head = head.Next
    }

    result := make([]int, 0, len(stack))
    for len(stack) > 0 {
        result = append(result, stack[len(stack)-1])
        stack = stack[:len(stack)-1]
    }

    return result
}
```

### [剑指 Offer 24. 反转链表](https://leetcode-cn.com/problems/fan-zhuan-lian-biao-lcof/)
**思路：**这题跟上一题有点类似，同样可以用栈或者递归解决，不过空间复杂度为O(n)。用双指针法可以把空间复杂度将为O(1)。
**注意：**思路很简单，但是想要写得简洁还是要考虑得比较清晰。另外容易忘记把head节点的next节点指向nil。
```Go
// 迭代版
func reverseList(head *ListNode) *ListNode {
    var prev *ListNode

    curr := head
    for curr != nil {
        next := curr.Next
        curr.Next = prev
        prev = curr
        curr = next
    }
    return prev
}
// 递归版
func reverseList(head *ListNode) *ListNode {
    if head == nil || head.Next == nil {
        return head
    }

    newHead := reverseList(head.Next)
    head.Next.Next = head
    head.Next = nil

    return newHead
}
```

### [剑指 Offer 35. 复杂链表的复制](https://leetcode-cn.com/problems/fu-za-lian-biao-de-fu-zhi-lcof/)
**思路：**先考虑一下没有随机节点的简单情况下怎么做，只需要遍历链表，为每个节点创建一个复制节点。有了随机节点后，主要要解决的问题是如何找到随机节点在新的链表中对应的节点，最容易相想到的也是我想到的方法是用哈希表记录原链表节点跟新节点之间的映射，额外的空间复杂度是O(n)。
**优化：**看了官方题解之后，发现可以把每个新节点链接在对应的原节点之后，省去了哈希表的额外空间。另外，除了迭代的方法，还可以用回溯的思想，代码更简洁。
```Go
var nodeMap map[*Node]*Node

func copyNode(origin *Node) *Node {
    if origin == nil {
        return nil
    }

    if node, ok := nodeMap[origin]; ok {
        return node
    }
    node := &Node{Val:origin.Val}
    nodeMap[origin] = node
    return node
}

func copyRandomList(head *Node) *Node {
    if head == nil {
        return nil
    }
    nodeMap = make(map[*Node]*Node)

    newHead := copyNode(head)
    curr := newHead
    for head != nil {
        curr.Next = copyNode(head.Next)
        curr.Random = copyNode(head.Random)

        curr = curr.Next
        head = head.Next
    }

    return newHead
}
```
